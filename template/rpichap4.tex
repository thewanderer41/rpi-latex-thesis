%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                 %
%                            CHAPTER FOUR                         %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{VERSIONING TABULAR DATA}\label{ch:spreadsheet}

This chapter uses the Copper and Noble Gas databases to demonstrate the implementation of the model presented in the previous chapter.

\section{VALIDATE COMPARISONS}

The first step in any versioning endeavor is to first establish that the two objects being compared meet the requirements of being each other's versions.
For the copper dataset, the objects result from a compilation effort from the same sources of data.
An entry recording the source material for each row in the table accompanies each reading.
As a result, these entries were used to determine that they share similar provenance.
They will also both be used as data inputs at the same step to generate data visualizations.
The datasets become interchangeable within the context of executing the workflow.
Determining whether the noble gas files are versions is a more challenging activity.
From provenance graphs like the one constructed for the entry CAM001 in Figure \ref{CAM001ProvGraph}, the entries share a common source document.
Likewise, a significant portion of the other entries also share sources from the same body of work.
The ones that do not are new or removed entries.
As there was no personal involvement in the use of this data set, determining whether they can occupy the same workflow step requires actually looking into the files.
Investigating column headers and the accompanying documentation reveals that they report many of the same measurements.
Some amount of leeway is given in this assessment as having every quantity match would mean that the two files aren't versions, but the same object.
This process helps to determine the confidence that using the model to encode the discovered changes will result in a meaningful versioning graph.

\begin{figure}
	\centering
	\includegraphics[scale=0.70]{figures/CAM001v1v2.png}
	\caption{Provenance graph for the CAM001 entry of the Noble Gas Database.  Other than the labels, the structure of each data object is very much the same.}
	\label{CAM001ProvGraph}
\end{figure}

\section{FORM A MAPPING}

The next step involves formulating a method to determine whether a relationship constitutes an add, invalidate, or modify mapping.
As discussed in the previous chapter, this relies on determining whether an attribute exists in one version, the other, or both.
However, with tabular data, a row and column attribute is required to match together specific cells.
For the Noble Gas dataset, this is conveniently the entry identifier and the column headers.
Row and column numbers are avoided because edits can result in the same entry associated with different indices.
In addition, the first version of the Noble Gas dataset was organized into multiple files so the same row index would appear more than once, and therefore, could not be used to match together related entries.
An observation that also simplifies identifying edits is that cells are rarely added or removed individually.
When one row gains a cell all other rows gain one as well, perhaps with null values, forming a new column.
As a result, data additions and invalidations only use one identifier.
A basic method to determine the identifiers involved in an addition is straight forward.
A set of identifiers \(\mathcal{A} = \mathcal{R}_{r} - \mathcal{R}_{l}\) where \(\mathcal{R}_{l}\) and \(\mathcal{R}_{r}\) correspond to the row identifiers of the left-hand and right-hand versions, respectively.
A converse procedure reveals the set of invalidated attributes \(\mathcal{I} = \mathcal{R}_{l} - \mathcal{R}_{r}\).
All the remaining identifiers exist in both versions and form a set of possible modification attributes.
These are only possibilities because the mapping procedure does not check for differences, and as a result, rows that have not undergone a change are also included.
The same is done with columns.
This only performs a very basic version mapping, but data producers can significantly improve this with their more intimate understanding of the versions.
For example, the base method would not understand that a Location column has been divided into two columns Latitude and Longitude.
A data producer could manually link the Location attribute to the Latitude and Longitude attributes, forming a single modification instead of an invalidate and two additions.

The copper minerals dataset starts each row with a unique mineral name, and these can be matched across datasets to determine if an entry has undergone a modification.
The column headers have different formats because the initial file is an Excel file and the other was a comma separated file.
As a result, the column headers were manually matched together with the remaining headers in each file mapped into the added and invalidated sets.
The noble gas database also uses unique identifiers to mark each of its entries, but the first version of the database divides data among multiple files.
For this reason, the identifiers must first be collected into a single dictionary data structure mapping identifiers to their files.
The version map is then computed from this data structure.
The database also uses multi-line headers which makes a basic automated approach difficult since the cells are not well aligned.
This means that the columns for this database also had to be mapped manually to find the matching columns.

\section{GENERATE VERSIONING GRAPH}

A versioning graph is now generated using the mapping method determined in the previous section.
Since the attributes in sets \(\mathcal{A}\) and \(\mathcal{I}\) guarantee a change, each item is encoded into linked data and output to a document.

\begin{lstlisting}[language=SPARQL, caption=Noble Gas Add Turle, label=NGA]
<http://rdfa.info/play/Version1> a vo:Version ;
	vo:absentFrom <http://rdfa.info/play/AddChange21> .
<http://rdfa.info/play/AddChange21> a <https://orion.tw.rpi.edu/~blee/VersionOntology.owl#AddChange> ;
	vo:resultsIn <http://rdfa.info/play/Attribute21> .
<http://rdfa.info/play/Attribute21> a <https://orion.tw.rpi.edu/~blee/VersionOntology.owl#Attribute> ;
	rdfs:label "EGY001"
<http://rdfa.info/play/Version2> a vo:Version ;
	vo:hasAttribute <http://rdfa.info/play/Attribute21>
\end{lstlisting}
Listing \ref{NGA} presents the statements in turtle format necessary to express that the entry EGY001 has been added to the dataset from Version 1 to Version 2 as shown in Figure \ref{NobleGraph1}.
Notice that the namespace for many of the URIs is \textlangle http://rdfa.info/play/\textrangle.
This results from the triples being extracted out of an HTML change log with embedded linked data, and this is used as the default namespace for the page.
Since we know the number of additions, each change instance can be easily numbered.
Add changes are also kept separate to allow for individual annotation.
Likewise, the graph generator iterates over the set of invalidations and generates a set of statements to instantiate each invalidate change.

However, Figure \ref{NobleGraph1} also demonstrates an interesting set of decisions made early in the generation process regarding modifications.
Firstly, the relation presented in the figure is unbalanced and the right-hand side of ChangeCAM00111 links only to the column identifier but not to the corresponding row attribute.
This links from a mismatch between the model's structure, the order in which data appears in the change log, and the way RDFa links properties together.
Because the row label forms the outermost encapsulation, it cannot instantiate both row identifiers and implicitly link them separately.
To do so would require explicitly instantiating the attribute in a non-visible part of the document which would defeat the purpose of using RDFa to implicitly encode the versioning graph into the document.
Secondly, the column identifier AttributeCAM00111v1 combines together the row label and the column number, making it unique to just the CAM001 row.
This was a decision to properly identify the attribute as it appears in the change log document.
Since the item is not a generic column 11 element in the log, but a specific item of CAM001, the entry id is included in the column identifier.
This formulation poses a problem when trying to query the graph and determine how many rows have a column 11 modify change for example.
When the versioning triples are not extracted from a change log and printed as linked data, the structure has greater freedom as seen in Figure \ref{NobleGraph2}.

\begin{figure}
	\centering
	\includegraphics[scale=0.30]{figures/NobleVersion.png}
	\caption{Some initial entries from versions 1 and 2 of the Noble Gas dataset}
	\label{NobleGraph1}
\end{figure}

\begin{figure}
	\centering
	\begin{adjustbox}{addcode={\begin{minipage}{\width}}{
					\caption{Versioning Graph representing the linked data graph with selected entries of additions, invalidations, and modifications. 
			}\end{minipage}},rotate=90,center}
		\includegraphics[scale=0.5]{figures/VersioningGraph2.png}%
	\end{adjustbox}
	\label{CopperGraphVerGraph}
\end{figure}

\section{MULTIPLE LINKED VERSIONS}

The figures in this document so far have depicted a comparison between only two versions, versioning often involves more than two objects, either in sequence or parallel.
Figure \ref{NobleGraph2} shows a graph that follows change as it moves through three versions of the Noble Gas data set.
From the first to second version of the data, EGY001 becomes introduced as an attribute into the dataset.
This entry then undergoes a modification change in columns 29, 31, and 43 when comparing versions two and three.
The construction results in a format naturally oriented to show the flow of change from version one to three.
The advantage of this formation is that now many versions can be related together using a unified set of semantics that cannot be achieved through combining the other concepts and properties in the previous chapter.
This is important since many versioning linked data alternatives view version change as a single contained activity.

Using the construction outlined in the previous three sections, many changes can be compiled together into a graph in a changelog.
After all additions, invalidations, and modifications have been compiled into a single graph, a complete mapping from version one to version two may be developed.
The orientation of the relationships in the graph allows a flow to be created from attributes in version one to corresponding attributes in version two.
Taking version two and performing the same graph construction to a version three results in not only a flow from version two to version three, but also from version one to version three.
As a result, the flow can be used to construct a mapping from version one to version three or any future version.

\begin{figure}
	\centering
	\begin{adjustbox}{addcode={\begin{minipage}{\width}}{
					\caption{Versioning Graph representing the linked data graph with selected entries of additions, invalidations, and modifications after the publication of the third version. 
			}\end{minipage}},rotate=90,center}
		\includegraphics[scale=0.5]{figures/NobleVersion2.png}%
	\end{adjustbox}
	\label{NobleGraph2}
\end{figure}